# 00 Async Closure

When you are new to hooks, you can struggle if you need to manage async callbacks and get
current values from useState, this doesn't work out of the box because the variables
generated by useState are frozen (following js closure principle you don't get the current
value).

How can we solve this? by using _useRef_

# Steps

- We will take as starting point sample _00 boilerplate_. Copy the content of the
  project to a fresh folder an execute _npm install_.

```bash
npm install
```

> If you come from the _context_ example remember to remove unused provider in _./src/index.js_

_./src/index.js_

```diff
import React from "react";
import ReactDOM from "react-dom";
- import { MyComponent, MyContextProvider } from "./demo";
+ import { MyComponent } from "./demo";

import "./styles.css";

function App() {
  return (
-    <MyContextProvider>
      <div className="App">
        <MyComponent />
      </div>
-    </MyContextProvider>
  );
}

const rootElement = document.getElementById("root");
ReactDOM.render(<App />, rootElement);
```

- Let's create an edge case, we will use _useEffect_. Inside we will have to asynchronous calls,
  the first one should setup a _seconds_ state to 1 (it will be executed after 1 seconds), then
  a second async call will be executed after 2 seconds of time elapse, in theory it should
  show the current seconds value (1) but instead we get 0. Let's give a try:

_./src/demo.js_

```jsx
import React from "react";

export const MyComponent = () => {
  const [message, setMessage] = React.useState("initial message");
  const [seconds, setSeconds] = React.useState(0);

  React.useEffect(() => {
    setTimeout(() => {
      console.log(seconds);
      setSeconds(seconds + 1);
    }, 1000);

    setTimeout(() => {
      setMessage(`Total seconds: ${seconds}`);
    }, 2000);
  }, []); // Important right click and ignore linter rule (later on check what happens)

  return (
    <>
      <h3>{message}</h3>
      <h4>{seconds}</h4>
    </>
  );
};
```

> Check the linter rule, is asking us to add seconds, we will explore this later on

- The problem here is that seconds points out to the previous value (check javascript closures
  for more information), how can we solve this? using _useRef_ (it will hold a mutable value in
  a field called _current_).

```diff
import React from "react";

export const MyComponent = () => {
  const [message, setMessage] = React.useState("initial message");
  const [seconds, setSeconds] = React.useState(0);

+ const secondsRef = React.useRef(seconds);


  React.useEffect(() => {
    setTimeout(() => {
      console.log(seconds);
      setSeconds(seconds + 1);
+      secondsRef.current = seconds + 1;
    }, 1000);

    setTimeout(() => {
-      setMessage(`Total seconds: ${seconds}`);
+      setMessage(`Total seconds: ${secondsRef.current}`);
    }, 2000);
  }, []);

  return (
    <>
      <h3>{message}</h3>
      <h4>{seconds}</h4>
    </>
  );
};
```

- Now if we run the sample we will get the expected behavior.

- What would happen if we follow the linter rule?

_./src/demo.js_

```diff
  React.useEffect(() => {
    setTimeout(() => {
      console.log(seconds);
      setSeconds(seconds + 1);
      secondsRef.current = seconds + 1;
    }, 1000);

    setTimeout(() => {
      setMessage(`Total seconds: ${secondsRef.current}`);
    }, 2000);
    // eslint-disable-next-line react-hooks/exhaustive-deps
-  }, []);
+  }, [seconds]);
```

All this excercise was great to know a bit about issues and edge
cases we can find when using hooks, but let's apply to real life
issues, let's cover the following case: we have a rich gmail client
running, we want to detect whether the user has an slow internet
connection to redirect him to the lite html client (less
functionallity but cover basic with decent speed on poor
connections).

https://codesandbox.io/s/ajax-checking-usestate-hx02u

# About Basefactor + Lemoncode

We are an innovating team of Javascript experts, passionate about turning your ideas into robust products.

[Basefactor, consultancy by Lemoncode](http://www.basefactor.com) provides consultancy and coaching services.

[Lemoncode](http://lemoncode.net/services/en/#en-home) provides training services.

For the LATAM/Spanish audience we are running an Online Front End Master degree, more info: http://lemoncode.net/master-frontend
